import sparse_causal_model_learner_rl.trainable.decoder
import sparse_causal_model_learner_rl.trainable.reconstructor
import sparse_causal_model_learner_rl.trainable.model
import sparse_causal_model_learner_rl.config
import sparse_causal_model_learner_rl.annealer.threshold
import sparse_causal_model_learner_rl.loss.losses
import sparse_causal_model_learner_rl.loss.optimizer
import sparse_causal_model_learner_rl.metrics.nnz
import sparse_causal_model_learner_rl.metrics.loss_thresholded
import gin_tune
import sparse_causal_model_learner_rl.trainable.value_predictor
import sparse_causal_model_learner_rl.trainable.fcnet
include 'kc_vf.gin'

tune_run.num_samples = 4
tune_run.resources_per_trial = {'gpu': 0.1, 'cpu': 1}

Config.train_steps = 2000000
Config.env_steps = 100000

Config.loss_every = 999999999999
Config.graph_every = 9999999999999
Config.checkpoint_every = 10000
Config.report_every = 100
Config.metrics_every = 100
Config.report_weights = False
Config.collect_every = 1000

Config.shuffle = True
Config.batch_training = True

Config.keep_history = True
Config.max_history_size = 1000

Config.model = None
Config.decoder = @IdentityDecoder
Config.reconstructor = None
Config.value_predictor = @ModelValuePredictor

value/FCNet.hidden_sizes = [2048, 1024, 512, 256, 64]
value/FCNet.activation_cls = @ReLU
ModelValuePredictor.model_cls = @value/FCNet

Config.feature_shape = None

Config._update_function = []

Config.losses = {
                 'reconstruction': {'fcn': @reconstruction_loss_value_function_reward_to_go, 'coeff': 1}
                }
Config.metrics = {}

opt1/Optimizer.name = 'Adam'

Config.optimizers = {'opt1': @opt1/Optimizer}
Config.execution = {'opt1': ['reconstruction']}
Config.optim_params = {'opt1': ['reconstructor']}
Config.opt_iterations = {'opt1': 1}